# 0. 高阶组件介绍

- 除了ref之外其他都可以传递
- 高阶组件是一个函数，参数是组件，返回值是组件的函数

# 1. 高阶组件理解
## 1.1 基础组件

```js
// 基础组件.js

class NormalComponent extends PureComponent{
  render(){
    return <div>hello</div>
  }
}

export default NormalComponent


// index.js

import NormalComponent from './基础组件.js'

ReactDOM.render(<NormalComponent />, document.getElementById('root'))

```

## 1.2. 高阶组件

```js
// 高阶组件.js

class NormalComponent extends PureComponent{
  render(){
    return <div>hello</div>
  }
}


function HeighOrderComponent(WrapperedComponent){
  // 这里返回一个类，类名NewComponent可以不用写，类似于返回一个匿名函数
  return Class NewComponent extends PureComponent{
    render(){
      return <WrapperedComponent />
    }
  }
}

const ContainerComponent = HeighOrderComponent(NormalComponent)
export default ContainerComponent


// index.js

import ContainerComponent from './高阶组件.js'

// ContainerComponent其实就是NewComponent
ReactDOM.render(<ContainerComponent />, document.getElementById('root'))

```

## 1.3. 高阶组件传参

```js

// 高阶组件.js

class NormalComponent extends PureComponent{
  render(){
    // hello why
    return <div>hello {this.props.name}</div>
  }
}

function HeighOrderComponent(WrapperedComponent){
  // 这里返回一个类，类名NewComponent可以不用写，类似于返回一个匿名函数
  return Class NewComponent extends PureComponent{
    render(){
      return <WrapperedComponent {...this.props}/>
    }
  }
}
const ContainerComponent = HeighOrderComponent(NormalComponent)
export default ContainerComponent


// index.js
import ContainerComponent from './高阶组件.js'
// ContainerComponent其实就是NewComponent, 所以参数name其实是传递给NewComponent组件，如果内部的WrapperedComponent组件()想获取，则需要通过props
// WrapperedComponent就是传入NormalComponent组件，所以在NormalComponent组件中可以根据this.props.name获取到why
ReactDOM.render(<ContainerComponent name="why"/>, document.getElementById('root'))

```

## 1.4. 高阶组件除了返回类还可以返回函数

```js
class NormalComponent extends PureComponent{
  render(){
    // hello why
    return <div>hello {this.props.name}</div>
  }
}


function HeighOrderComponent(WrapperedComponent){
  // 这里除了返回类之外还可以返回函数；不过传参是props而不是this.props
  function NewComponent(props){
    return <WrapperedComponent {...props}/>
  }
  return NewComponent
}

const ContainerComponent = HeighOrderComponent(NormalComponent)
export default ContainerComponent


// index.js

import ContainerComponent from './高阶组件.js'
ReactDOM.render(<ContainerComponent name="why"/>, document.getElementById('root'))
```

# 2. 高阶组件应用
## 2.1 应用之高阶组件增强props

```js

class App extends PureComponent{
  render(){
    return <div>App
      <Home nickname="home" level={10}/>
      <About nickname="about" level={9}/>
    </div>
  }
}


class Home extends PureComponent{
  render(){
    return <div>{`昵称：${this.props.nickname}--等级： ${this.props.level}--国家：${this.props.country}`}</div>
  }
}

class About extends PureComponent{
  render(){
    return <div>{`昵称：${this.props.nickname}--等级： ${this.props.level}--国家：${this.props.country}`}</div>
  }
}


// 如果此时想增加一个国家属性
// 不采用高阶组件时：每个引入<Home nickname="home" level={10}/>和<About nickname="about" level={9}/>的地方都需要修改，增加country属性

<Home nickname="home" level={10} country="中国"/>
<About nickname="about" level={9} country="中国"/>

// 采用高阶组件时（后面想增加什么属性直接在高阶组件中增加就行，外部引用Home和About组件的地方不需要修改）：
function enhanceProps(WrapperedComponent){
  return props => <WrapperedComponent {...props} country="中国"/>
}



const EnhanceHome = enhanceProps(Home)
const EnhanceAbout = enhanceProps(About)


class App extends PureComponent{
  render(){
    return <div>App
      {/* 下面 将Home修改为EnhanceHome是因为目前在同一个js文件中，如果在不同的文件时，则不需要修改，因为导出的时候直接使用export default enhanceProps(Home)*/}
      <EnhanceHome nickname="home" level={10}/>
      <EnhanceAbout nickname="about" level={9}/>
    </div>
  }
}

```
## 2.2 应用之共享数据并抽取公共部分

- context+高阶组件场景：多组件共享相同数据；比如Home和About都需要用到nickname="home" level=10

- 高阶组件：封装公共部分

```js
const UserContext = creatContext({
  nickname: 'home',
  level: 10,
  country: ''
})


class App extends PureComponent{
  render(){
    return <div>
      App
      <UserContext.Provider value={{nickname: 'home',level: 10, country: '中国'}}>
        {/* <UserHome arg="这里可以单独传参，会传入到props"/> */}
        <UserHome />
        <UserAbout />
      </UserContext.Provider>
    </div>
  }
}

// 封装的公共高阶组件
function withEnhance(WrapperedComponent){
  return props =>
  <UserContext.Consumer>
    {
      user => <WrapperedComponent {...props} {...user}/>
    }
  </UserContext.Consumer>
}


const UserHome = withEnhance(Home)
const UserAbout = withEnhance(About)

class Home extends PureComponent{
  render(){
    return <h2>{`昵称：${this.props.nickname}--等级： ${this.props.level}--国家：${this.props.country}`}</h2>
  }
}

class About extends PureComponent{
  render(){
    return
    <ul>
      <li>{this.props.nickname}</li>
      <li>{this.props.level}</li>
      <li>{this.props.country}</li>
    </ul>
  }
}


// 不使用高阶组件时：Home组件和About组件渲染都需要写UserContext.Consumer；使用高阶组件之后将公共UserContext.Consumer提取
class Home extends PureComponent{
  render(){
    return <UserContext.Consumer>
      {user => <h2>{`昵称：${user.nickname}--等级： ${user.level}--国家：${user.country}`}</h2>}
    </UserContext.Consumer>

  }
}

class About extends PureComponent{
  render(){
    return
    <UserContext.Consumer>
    {
        user =>
          <ul>
          <li>{user.nickname}</li>
          <li>{user.level}</li>
          <li>{user.country}</li>
          </ul>
    }
    </UserContext.Consumer>
  }
}
```
  
## 2.3 应用之登录鉴权

背景：比如进入购物车页面、商详页等多个页面，都需要查看是否登录，如果登录，则进入对应页面否则跳转登录页

思路：抽取公共鉴权部分为高阶组件














