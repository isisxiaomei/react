{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.warnOnlyTreeNode = warnOnlyTreeNode;\nexports.arrDel = arrDel;\nexports.arrAdd = arrAdd;\nexports.posToArr = posToArr;\nexports.getPosition = getPosition;\nexports.isTreeNode = isTreeNode;\nexports.getNodeChildren = getNodeChildren;\nexports.isCheckDisabled = isCheckDisabled;\nexports.traverseTreeNodes = traverseTreeNodes;\nexports.mapChildren = mapChildren;\nexports.getDragNodesKeys = getDragNodesKeys;\nexports.calcDropPosition = calcDropPosition;\nexports.calcSelectedKeys = calcSelectedKeys;\nexports.convertDataToTree = convertDataToTree;\nexports.convertTreeToEntities = convertTreeToEntities;\nexports.parseCheckedKeys = parseCheckedKeys;\nexports.conductCheck = conductCheck;\nexports.conductExpandParent = conductExpandParent;\nexports.getDataAndAria = getDataAndAria;\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _toArray = _interopRequireDefault(require(\"rc-util/lib/Children/toArray\"));\n\nvar _warning = _interopRequireDefault(require(\"warning\"));\n\nvar _TreeNode = _interopRequireDefault(require(\"./TreeNode\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nvar DRAG_SIDE_RANGE = 0.25;\nvar DRAG_MIN_GAP = 2;\nvar onlyTreeNodeWarned = false;\n\nfunction warnOnlyTreeNode() {\n  if (onlyTreeNodeWarned) return;\n  onlyTreeNodeWarned = true;\n  (0, _warning.default)(false, 'Tree only accept TreeNode as children.');\n}\n\nfunction arrDel(list, value) {\n  var clone = list.slice();\n  var index = clone.indexOf(value);\n\n  if (index >= 0) {\n    clone.splice(index, 1);\n  }\n\n  return clone;\n}\n\nfunction arrAdd(list, value) {\n  var clone = list.slice();\n\n  if (clone.indexOf(value) === -1) {\n    clone.push(value);\n  }\n\n  return clone;\n}\n\nfunction posToArr(pos) {\n  return pos.split('-');\n}\n\nfunction getPosition(level, index) {\n  return \"\".concat(level, \"-\").concat(index);\n}\n\nfunction isTreeNode(node) {\n  return node && node.type && node.type.isTreeNode;\n}\n\nfunction getNodeChildren(children) {\n  return (0, _toArray.default)(children).filter(isTreeNode);\n}\n\nfunction isCheckDisabled(node) {\n  var _ref = node.props || {},\n      disabled = _ref.disabled,\n      disableCheckbox = _ref.disableCheckbox,\n      checkable = _ref.checkable;\n\n  return !!(disabled || disableCheckbox) || checkable === false;\n}\n\nfunction traverseTreeNodes(treeNodes, callback) {\n  function processNode(node, index, parent) {\n    var children = node ? node.props.children : treeNodes;\n    var pos = node ? getPosition(parent.pos, index) : 0; // Filter children\n\n    var childList = getNodeChildren(children); // Process node if is not root\n\n    if (node) {\n      var data = {\n        node: node,\n        index: index,\n        pos: pos,\n        key: node.key || pos,\n        parentPos: parent.node ? parent.pos : null\n      };\n      callback(data);\n    } // Process children node\n\n\n    _react.Children.forEach(childList, function (subNode, subIndex) {\n      processNode(subNode, subIndex, {\n        node: node,\n        pos: pos\n      });\n    });\n  }\n\n  processNode(null);\n}\n/**\n * Use `rc-util` `toArray` to get the children list which keeps the key.\n * And return single node if children is only one(This can avoid `key` missing check).\n */\n\n\nfunction mapChildren(children, func) {\n  var list = (0, _toArray.default)(children).map(func);\n\n  if (list.length === 1) {\n    return list[0];\n  }\n\n  return list;\n}\n\nfunction getDragNodesKeys(treeNodes, node) {\n  var _node$props = node.props,\n      eventKey = _node$props.eventKey,\n      pos = _node$props.pos;\n  var dragNodesKeys = [];\n  traverseTreeNodes(treeNodes, function (_ref2) {\n    var key = _ref2.key;\n    dragNodesKeys.push(key);\n  });\n  dragNodesKeys.push(eventKey || pos);\n  return dragNodesKeys;\n} // Only used when drag, not affect SSR.\n\n\nfunction calcDropPosition(event, treeNode) {\n  var clientY = event.clientY;\n\n  var _treeNode$selectHandl = treeNode.selectHandle.getBoundingClientRect(),\n      top = _treeNode$selectHandl.top,\n      bottom = _treeNode$selectHandl.bottom,\n      height = _treeNode$selectHandl.height;\n\n  var des = Math.max(height * DRAG_SIDE_RANGE, DRAG_MIN_GAP);\n\n  if (clientY <= top + des) {\n    return -1;\n  }\n\n  if (clientY >= bottom - des) {\n    return 1;\n  }\n\n  return 0;\n}\n/**\n * Return selectedKeys according with multiple prop\n * @param selectedKeys\n * @param props\n * @returns [string]\n */\n\n\nfunction calcSelectedKeys(selectedKeys, props) {\n  if (!selectedKeys) return undefined;\n  var multiple = props.multiple;\n\n  if (multiple) {\n    return selectedKeys.slice();\n  }\n\n  if (selectedKeys.length) {\n    return [selectedKeys[0]];\n  }\n\n  return selectedKeys;\n}\n/**\n * Since React internal will convert key to string,\n * we need do this to avoid `checkStrictly` use number match\n */\n\n\nfunction keyListToString(keyList) {\n  if (!keyList) return keyList;\n  return keyList.map(function (key) {\n    return String(key);\n  });\n}\n\nvar internalProcessProps = function internalProcessProps(props) {\n  return props;\n};\n\nfunction convertDataToTree(treeData, processor) {\n  if (!treeData) return [];\n\n  var _ref3 = processor || {},\n      _ref3$processProps = _ref3.processProps,\n      processProps = _ref3$processProps === void 0 ? internalProcessProps : _ref3$processProps;\n\n  var list = Array.isArray(treeData) ? treeData : [treeData];\n  return list.map(function (_ref4) {\n    var children = _ref4.children,\n        props = _objectWithoutProperties(_ref4, [\"children\"]);\n\n    var childrenNodes = convertDataToTree(children, processor);\n    return _react.default.createElement(_TreeNode.default, Object.assign({}, processProps(props)), childrenNodes);\n  });\n}\n/**\n * Calculate treeNodes entities. `processTreeEntity` is used for `rc-tree-select`\n * @param treeNodes\n * @param processTreeEntity  User can customize the entity\n */\n\n\nfunction convertTreeToEntities(treeNodes) {\n  var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      initWrapper = _ref5.initWrapper,\n      processEntity = _ref5.processEntity,\n      onProcessFinished = _ref5.onProcessFinished;\n\n  var posEntities = {};\n  var keyEntities = {};\n  var wrapper = {\n    posEntities: posEntities,\n    keyEntities: keyEntities\n  };\n\n  if (initWrapper) {\n    wrapper = initWrapper(wrapper) || wrapper;\n  }\n\n  traverseTreeNodes(treeNodes, function (item) {\n    var node = item.node,\n        index = item.index,\n        pos = item.pos,\n        key = item.key,\n        parentPos = item.parentPos;\n    var entity = {\n      node: node,\n      index: index,\n      key: key,\n      pos: pos\n    };\n    posEntities[pos] = entity;\n    keyEntities[key] = entity; // Fill children\n\n    entity.parent = posEntities[parentPos];\n\n    if (entity.parent) {\n      entity.parent.children = entity.parent.children || [];\n      entity.parent.children.push(entity);\n    }\n\n    if (processEntity) {\n      processEntity(entity, wrapper);\n    }\n  });\n\n  if (onProcessFinished) {\n    onProcessFinished(wrapper);\n  }\n\n  return wrapper;\n}\n/**\n * Parse `checkedKeys` to { checkedKeys, halfCheckedKeys } style\n */\n\n\nfunction parseCheckedKeys(keys) {\n  if (!keys) {\n    return null;\n  } // Convert keys to object format\n\n\n  var keyProps;\n\n  if (Array.isArray(keys)) {\n    // [Legacy] Follow the api doc\n    keyProps = {\n      checkedKeys: keys,\n      halfCheckedKeys: undefined\n    };\n  } else if (_typeof(keys) === 'object') {\n    keyProps = {\n      checkedKeys: keys.checked || undefined,\n      halfCheckedKeys: keys.halfChecked || undefined\n    };\n  } else {\n    (0, _warning.default)(false, '`checkedKeys` is not an array or an object');\n    return null;\n  }\n\n  keyProps.checkedKeys = keyListToString(keyProps.checkedKeys);\n  keyProps.halfCheckedKeys = keyListToString(keyProps.halfCheckedKeys);\n  return keyProps;\n}\n/**\n * Conduct check state by the keyList. It will conduct up & from the provided key.\n * If the conduct path reach the disabled or already checked / unchecked node will stop conduct.\n */\n\n\nfunction conductCheck(\n/** list of keys */\nkeyList,\n/** is check the node or not */\nisCheck,\n/** parsed by `convertTreeToEntities` function in Tree */\nkeyEntities) {\n  var checkStatus = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var checkedKeys = {};\n  var halfCheckedKeys = {}; // Record the key has some child checked (include child half checked)\n\n  (checkStatus.checkedKeys || []).forEach(function (key) {\n    checkedKeys[key] = true;\n  });\n  (checkStatus.halfCheckedKeys || []).forEach(function (key) {\n    halfCheckedKeys[key] = true;\n  }); // Conduct up\n\n  function conductUp(key) {\n    if (checkedKeys[key] === isCheck) return;\n    var entity = keyEntities[key];\n    if (!entity) return;\n    var children = entity.children,\n        parent = entity.parent,\n        node = entity.node;\n    if (isCheckDisabled(node)) return; // Check child node checked status\n\n    var everyChildChecked = true;\n    var someChildChecked = false; // Child checked or half checked\n\n    (children || []).filter(function (child) {\n      return !isCheckDisabled(child.node);\n    }).forEach(function (_ref6) {\n      var childKey = _ref6.key;\n      var childChecked = checkedKeys[childKey];\n      var childHalfChecked = halfCheckedKeys[childKey];\n      if (childChecked || childHalfChecked) someChildChecked = true;\n      if (!childChecked) everyChildChecked = false;\n    }); // Update checked status\n\n    if (isCheck) {\n      checkedKeys[key] = everyChildChecked;\n    } else {\n      checkedKeys[key] = false;\n    }\n\n    halfCheckedKeys[key] = someChildChecked;\n\n    if (parent) {\n      conductUp(parent.key);\n    }\n  } // Conduct down\n\n\n  function conductDown(key) {\n    if (checkedKeys[key] === isCheck) return;\n    var entity = keyEntities[key];\n    if (!entity) return;\n    var children = entity.children,\n        node = entity.node;\n    if (isCheckDisabled(node)) return;\n    checkedKeys[key] = isCheck;\n    (children || []).forEach(function (child) {\n      conductDown(child.key);\n    });\n  }\n\n  function conduct(key) {\n    var entity = keyEntities[key];\n\n    if (!entity) {\n      (0, _warning.default)(false, \"'\".concat(key, \"' does not exist in the tree.\"));\n      return;\n    }\n\n    var children = entity.children,\n        parent = entity.parent,\n        node = entity.node;\n    checkedKeys[key] = isCheck;\n    if (isCheckDisabled(node)) return; // Conduct down\n\n    (children || []).filter(function (child) {\n      return !isCheckDisabled(child.node);\n    }).forEach(function (child) {\n      conductDown(child.key);\n    }); // Conduct up\n\n    if (parent) {\n      conductUp(parent.key);\n    }\n  }\n\n  (keyList || []).forEach(function (key) {\n    conduct(key);\n  });\n  var checkedKeyList = [];\n  var halfCheckedKeyList = []; // Fill checked list\n\n  Object.keys(checkedKeys).forEach(function (key) {\n    if (checkedKeys[key]) {\n      checkedKeyList.push(key);\n    }\n  }); // Fill half checked list\n\n  Object.keys(halfCheckedKeys).forEach(function (key) {\n    if (!checkedKeys[key] && halfCheckedKeys[key]) {\n      halfCheckedKeyList.push(key);\n    }\n  });\n  return {\n    checkedKeys: checkedKeyList,\n    halfCheckedKeys: halfCheckedKeyList\n  };\n}\n/**\n * If user use `autoExpandParent` we should get the list of parent node\n * @param keyList\n * @param keyEntities\n */\n\n\nfunction conductExpandParent(keyList, keyEntities) {\n  var expandedKeys = {};\n\n  function conductUp(key) {\n    if (expandedKeys[key]) return;\n    var entity = keyEntities[key];\n    if (!entity) return;\n    expandedKeys[key] = true;\n    var parent = entity.parent,\n        node = entity.node;\n    if (node.props && node.props.disabled) return;\n\n    if (parent) {\n      conductUp(parent.key);\n    }\n  }\n\n  (keyList || []).forEach(function (key) {\n    conductUp(key);\n  });\n  return Object.keys(expandedKeys);\n}\n/**\n * Returns only the data- and aria- key/value pairs\n */\n\n\nfunction getDataAndAria(props) {\n  return Object.keys(props).reduce(function (prev, key) {\n    if (key.substr(0, 5) === 'data-' || key.substr(0, 5) === 'aria-') {\n      prev[key] = props[key];\n    }\n\n    return prev;\n  }, {});\n}","map":{"version":3,"sources":["/Users/xumeihong/Documents/code/git/react/demos/demo2/node_modules/rc-tree/lib/util.js"],"names":["Object","defineProperty","exports","value","warnOnlyTreeNode","arrDel","arrAdd","posToArr","getPosition","isTreeNode","getNodeChildren","isCheckDisabled","traverseTreeNodes","mapChildren","getDragNodesKeys","calcDropPosition","calcSelectedKeys","convertDataToTree","convertTreeToEntities","parseCheckedKeys","conductCheck","conductExpandParent","getDataAndAria","_react","_interopRequireWildcard","require","_toArray","_interopRequireDefault","_warning","_TreeNode","obj","__esModule","default","_getRequireWildcardCache","WeakMap","cache","_typeof","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","Symbol","iterator","constructor","_objectWithoutProperties","source","excluded","target","_objectWithoutPropertiesLoose","i","getOwnPropertySymbols","sourceSymbolKeys","length","indexOf","propertyIsEnumerable","sourceKeys","keys","DRAG_SIDE_RANGE","DRAG_MIN_GAP","onlyTreeNodeWarned","list","clone","slice","index","splice","push","pos","split","level","concat","node","type","children","filter","_ref","props","disabled","disableCheckbox","checkable","treeNodes","callback","processNode","parent","childList","data","parentPos","Children","forEach","subNode","subIndex","func","map","_node$props","eventKey","dragNodesKeys","_ref2","event","treeNode","clientY","_treeNode$selectHandl","selectHandle","getBoundingClientRect","top","bottom","height","des","Math","max","selectedKeys","undefined","multiple","keyListToString","keyList","String","internalProcessProps","treeData","processor","_ref3","_ref3$processProps","processProps","Array","isArray","_ref4","childrenNodes","createElement","assign","_ref5","arguments","initWrapper","processEntity","onProcessFinished","posEntities","keyEntities","wrapper","item","entity","keyProps","checkedKeys","halfCheckedKeys","checked","halfChecked","isCheck","checkStatus","conductUp","everyChildChecked","someChildChecked","child","_ref6","childKey","childChecked","childHalfChecked","conductDown","conduct","checkedKeyList","halfCheckedKeyList","expandedKeys","reduce","prev","substr"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.warnOnlyTreeNode = warnOnlyTreeNode;\nexports.arrDel = arrDel;\nexports.arrAdd = arrAdd;\nexports.posToArr = posToArr;\nexports.getPosition = getPosition;\nexports.isTreeNode = isTreeNode;\nexports.getNodeChildren = getNodeChildren;\nexports.isCheckDisabled = isCheckDisabled;\nexports.traverseTreeNodes = traverseTreeNodes;\nexports.mapChildren = mapChildren;\nexports.getDragNodesKeys = getDragNodesKeys;\nexports.calcDropPosition = calcDropPosition;\nexports.calcSelectedKeys = calcSelectedKeys;\nexports.convertDataToTree = convertDataToTree;\nexports.convertTreeToEntities = convertTreeToEntities;\nexports.parseCheckedKeys = parseCheckedKeys;\nexports.conductCheck = conductCheck;\nexports.conductExpandParent = conductExpandParent;\nexports.getDataAndAria = getDataAndAria;\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _toArray = _interopRequireDefault(require(\"rc-util/lib/Children/toArray\"));\n\nvar _warning = _interopRequireDefault(require(\"warning\"));\n\nvar _TreeNode = _interopRequireDefault(require(\"./TreeNode\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nvar DRAG_SIDE_RANGE = 0.25;\nvar DRAG_MIN_GAP = 2;\nvar onlyTreeNodeWarned = false;\n\nfunction warnOnlyTreeNode() {\n  if (onlyTreeNodeWarned) return;\n  onlyTreeNodeWarned = true;\n  (0, _warning.default)(false, 'Tree only accept TreeNode as children.');\n}\n\nfunction arrDel(list, value) {\n  var clone = list.slice();\n  var index = clone.indexOf(value);\n\n  if (index >= 0) {\n    clone.splice(index, 1);\n  }\n\n  return clone;\n}\n\nfunction arrAdd(list, value) {\n  var clone = list.slice();\n\n  if (clone.indexOf(value) === -1) {\n    clone.push(value);\n  }\n\n  return clone;\n}\n\nfunction posToArr(pos) {\n  return pos.split('-');\n}\n\nfunction getPosition(level, index) {\n  return \"\".concat(level, \"-\").concat(index);\n}\n\nfunction isTreeNode(node) {\n  return node && node.type && node.type.isTreeNode;\n}\n\nfunction getNodeChildren(children) {\n  return (0, _toArray.default)(children).filter(isTreeNode);\n}\n\nfunction isCheckDisabled(node) {\n  var _ref = node.props || {},\n      disabled = _ref.disabled,\n      disableCheckbox = _ref.disableCheckbox,\n      checkable = _ref.checkable;\n\n  return !!(disabled || disableCheckbox) || checkable === false;\n}\n\nfunction traverseTreeNodes(treeNodes, callback) {\n  function processNode(node, index, parent) {\n    var children = node ? node.props.children : treeNodes;\n    var pos = node ? getPosition(parent.pos, index) : 0; // Filter children\n\n    var childList = getNodeChildren(children); // Process node if is not root\n\n    if (node) {\n      var data = {\n        node: node,\n        index: index,\n        pos: pos,\n        key: node.key || pos,\n        parentPos: parent.node ? parent.pos : null\n      };\n      callback(data);\n    } // Process children node\n\n\n    _react.Children.forEach(childList, function (subNode, subIndex) {\n      processNode(subNode, subIndex, {\n        node: node,\n        pos: pos\n      });\n    });\n  }\n\n  processNode(null);\n}\n/**\n * Use `rc-util` `toArray` to get the children list which keeps the key.\n * And return single node if children is only one(This can avoid `key` missing check).\n */\n\n\nfunction mapChildren(children, func) {\n  var list = (0, _toArray.default)(children).map(func);\n\n  if (list.length === 1) {\n    return list[0];\n  }\n\n  return list;\n}\n\nfunction getDragNodesKeys(treeNodes, node) {\n  var _node$props = node.props,\n      eventKey = _node$props.eventKey,\n      pos = _node$props.pos;\n  var dragNodesKeys = [];\n  traverseTreeNodes(treeNodes, function (_ref2) {\n    var key = _ref2.key;\n    dragNodesKeys.push(key);\n  });\n  dragNodesKeys.push(eventKey || pos);\n  return dragNodesKeys;\n} // Only used when drag, not affect SSR.\n\n\nfunction calcDropPosition(event, treeNode) {\n  var clientY = event.clientY;\n\n  var _treeNode$selectHandl = treeNode.selectHandle.getBoundingClientRect(),\n      top = _treeNode$selectHandl.top,\n      bottom = _treeNode$selectHandl.bottom,\n      height = _treeNode$selectHandl.height;\n\n  var des = Math.max(height * DRAG_SIDE_RANGE, DRAG_MIN_GAP);\n\n  if (clientY <= top + des) {\n    return -1;\n  }\n\n  if (clientY >= bottom - des) {\n    return 1;\n  }\n\n  return 0;\n}\n/**\n * Return selectedKeys according with multiple prop\n * @param selectedKeys\n * @param props\n * @returns [string]\n */\n\n\nfunction calcSelectedKeys(selectedKeys, props) {\n  if (!selectedKeys) return undefined;\n  var multiple = props.multiple;\n\n  if (multiple) {\n    return selectedKeys.slice();\n  }\n\n  if (selectedKeys.length) {\n    return [selectedKeys[0]];\n  }\n\n  return selectedKeys;\n}\n/**\n * Since React internal will convert key to string,\n * we need do this to avoid `checkStrictly` use number match\n */\n\n\nfunction keyListToString(keyList) {\n  if (!keyList) return keyList;\n  return keyList.map(function (key) {\n    return String(key);\n  });\n}\n\nvar internalProcessProps = function internalProcessProps(props) {\n  return props;\n};\n\nfunction convertDataToTree(treeData, processor) {\n  if (!treeData) return [];\n\n  var _ref3 = processor || {},\n      _ref3$processProps = _ref3.processProps,\n      processProps = _ref3$processProps === void 0 ? internalProcessProps : _ref3$processProps;\n\n  var list = Array.isArray(treeData) ? treeData : [treeData];\n  return list.map(function (_ref4) {\n    var children = _ref4.children,\n        props = _objectWithoutProperties(_ref4, [\"children\"]);\n\n    var childrenNodes = convertDataToTree(children, processor);\n    return _react.default.createElement(_TreeNode.default, Object.assign({}, processProps(props)), childrenNodes);\n  });\n}\n/**\n * Calculate treeNodes entities. `processTreeEntity` is used for `rc-tree-select`\n * @param treeNodes\n * @param processTreeEntity  User can customize the entity\n */\n\n\nfunction convertTreeToEntities(treeNodes) {\n  var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      initWrapper = _ref5.initWrapper,\n      processEntity = _ref5.processEntity,\n      onProcessFinished = _ref5.onProcessFinished;\n\n  var posEntities = {};\n  var keyEntities = {};\n  var wrapper = {\n    posEntities: posEntities,\n    keyEntities: keyEntities\n  };\n\n  if (initWrapper) {\n    wrapper = initWrapper(wrapper) || wrapper;\n  }\n\n  traverseTreeNodes(treeNodes, function (item) {\n    var node = item.node,\n        index = item.index,\n        pos = item.pos,\n        key = item.key,\n        parentPos = item.parentPos;\n    var entity = {\n      node: node,\n      index: index,\n      key: key,\n      pos: pos\n    };\n    posEntities[pos] = entity;\n    keyEntities[key] = entity; // Fill children\n\n    entity.parent = posEntities[parentPos];\n\n    if (entity.parent) {\n      entity.parent.children = entity.parent.children || [];\n      entity.parent.children.push(entity);\n    }\n\n    if (processEntity) {\n      processEntity(entity, wrapper);\n    }\n  });\n\n  if (onProcessFinished) {\n    onProcessFinished(wrapper);\n  }\n\n  return wrapper;\n}\n/**\n * Parse `checkedKeys` to { checkedKeys, halfCheckedKeys } style\n */\n\n\nfunction parseCheckedKeys(keys) {\n  if (!keys) {\n    return null;\n  } // Convert keys to object format\n\n\n  var keyProps;\n\n  if (Array.isArray(keys)) {\n    // [Legacy] Follow the api doc\n    keyProps = {\n      checkedKeys: keys,\n      halfCheckedKeys: undefined\n    };\n  } else if (_typeof(keys) === 'object') {\n    keyProps = {\n      checkedKeys: keys.checked || undefined,\n      halfCheckedKeys: keys.halfChecked || undefined\n    };\n  } else {\n    (0, _warning.default)(false, '`checkedKeys` is not an array or an object');\n    return null;\n  }\n\n  keyProps.checkedKeys = keyListToString(keyProps.checkedKeys);\n  keyProps.halfCheckedKeys = keyListToString(keyProps.halfCheckedKeys);\n  return keyProps;\n}\n/**\n * Conduct check state by the keyList. It will conduct up & from the provided key.\n * If the conduct path reach the disabled or already checked / unchecked node will stop conduct.\n */\n\n\nfunction conductCheck(\n/** list of keys */\nkeyList,\n/** is check the node or not */\nisCheck,\n/** parsed by `convertTreeToEntities` function in Tree */\nkeyEntities) {\n  var checkStatus = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var checkedKeys = {};\n  var halfCheckedKeys = {}; // Record the key has some child checked (include child half checked)\n\n  (checkStatus.checkedKeys || []).forEach(function (key) {\n    checkedKeys[key] = true;\n  });\n  (checkStatus.halfCheckedKeys || []).forEach(function (key) {\n    halfCheckedKeys[key] = true;\n  }); // Conduct up\n\n  function conductUp(key) {\n    if (checkedKeys[key] === isCheck) return;\n    var entity = keyEntities[key];\n    if (!entity) return;\n    var children = entity.children,\n        parent = entity.parent,\n        node = entity.node;\n    if (isCheckDisabled(node)) return; // Check child node checked status\n\n    var everyChildChecked = true;\n    var someChildChecked = false; // Child checked or half checked\n\n    (children || []).filter(function (child) {\n      return !isCheckDisabled(child.node);\n    }).forEach(function (_ref6) {\n      var childKey = _ref6.key;\n      var childChecked = checkedKeys[childKey];\n      var childHalfChecked = halfCheckedKeys[childKey];\n      if (childChecked || childHalfChecked) someChildChecked = true;\n      if (!childChecked) everyChildChecked = false;\n    }); // Update checked status\n\n    if (isCheck) {\n      checkedKeys[key] = everyChildChecked;\n    } else {\n      checkedKeys[key] = false;\n    }\n\n    halfCheckedKeys[key] = someChildChecked;\n\n    if (parent) {\n      conductUp(parent.key);\n    }\n  } // Conduct down\n\n\n  function conductDown(key) {\n    if (checkedKeys[key] === isCheck) return;\n    var entity = keyEntities[key];\n    if (!entity) return;\n    var children = entity.children,\n        node = entity.node;\n    if (isCheckDisabled(node)) return;\n    checkedKeys[key] = isCheck;\n    (children || []).forEach(function (child) {\n      conductDown(child.key);\n    });\n  }\n\n  function conduct(key) {\n    var entity = keyEntities[key];\n\n    if (!entity) {\n      (0, _warning.default)(false, \"'\".concat(key, \"' does not exist in the tree.\"));\n      return;\n    }\n\n    var children = entity.children,\n        parent = entity.parent,\n        node = entity.node;\n    checkedKeys[key] = isCheck;\n    if (isCheckDisabled(node)) return; // Conduct down\n\n    (children || []).filter(function (child) {\n      return !isCheckDisabled(child.node);\n    }).forEach(function (child) {\n      conductDown(child.key);\n    }); // Conduct up\n\n    if (parent) {\n      conductUp(parent.key);\n    }\n  }\n\n  (keyList || []).forEach(function (key) {\n    conduct(key);\n  });\n  var checkedKeyList = [];\n  var halfCheckedKeyList = []; // Fill checked list\n\n  Object.keys(checkedKeys).forEach(function (key) {\n    if (checkedKeys[key]) {\n      checkedKeyList.push(key);\n    }\n  }); // Fill half checked list\n\n  Object.keys(halfCheckedKeys).forEach(function (key) {\n    if (!checkedKeys[key] && halfCheckedKeys[key]) {\n      halfCheckedKeyList.push(key);\n    }\n  });\n  return {\n    checkedKeys: checkedKeyList,\n    halfCheckedKeys: halfCheckedKeyList\n  };\n}\n/**\n * If user use `autoExpandParent` we should get the list of parent node\n * @param keyList\n * @param keyEntities\n */\n\n\nfunction conductExpandParent(keyList, keyEntities) {\n  var expandedKeys = {};\n\n  function conductUp(key) {\n    if (expandedKeys[key]) return;\n    var entity = keyEntities[key];\n    if (!entity) return;\n    expandedKeys[key] = true;\n    var parent = entity.parent,\n        node = entity.node;\n    if (node.props && node.props.disabled) return;\n\n    if (parent) {\n      conductUp(parent.key);\n    }\n  }\n\n  (keyList || []).forEach(function (key) {\n    conductUp(key);\n  });\n  return Object.keys(expandedKeys);\n}\n/**\n * Returns only the data- and aria- key/value pairs\n */\n\n\nfunction getDataAndAria(props) {\n  return Object.keys(props).reduce(function (prev, key) {\n    if (key.substr(0, 5) === 'data-' || key.substr(0, 5) === 'aria-') {\n      prev[key] = props[key];\n    }\n\n    return prev;\n  }, {});\n}"]},"metadata":{},"sourceType":"script"}